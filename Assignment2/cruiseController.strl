% pedal detection (Krithik) NOT REALLY NEEDED
% module PedalDetection:
% 	input accel : float, brake : float;
% 	output accelPressed : boolean, brakePressed : boolean;

% 	var pedalsMin := 0.03 : float in
% 		loop
% 			pause;
% 				% Emit if pedal pressed enough
% 				if (?accel >= 0.03) then
% 					emit accelPressed(true)
% 				elsif (?brake >= 0.03) then
% 					emit brakePressed(true)
% 				end if;

% 				% Reset accelPressed/brakePressed when input low
% 				if (?accel < 0.03) then
% 					emit accelPressed(false)
% 				end if;

% 				if (?brake < 0.03) then
% 					emit brakePressed(false)
% 				end if;
% 		end loop
% 	end var
% end module

% Cruise Speed Management (Krithik)

module SpeedManagement:
	input speed : float;
	input on : boolean, set : boolean, quickAccel : boolean, quickDecel : boolean;
	output cruiseSpeed : float; 
	output cruiseState : integer;

	function checkSpeedInRange(float) : boolean;
	function checkSpeedIncrement(float, boolean, boolean) : boolean;
	
	var onPressedOut := false : boolean, isEnabled := false : boolean, speedInRange : boolean, checkSpeedInc : boolean in
	var speedInc := 2.5f : float, cruiseSpeedOut := 0.0f : float in
	loop
		pause;
			speedInRange := checkSpeedInRange(?speed);
			checkSpeedInc := checkSpeedIncrement(cruiseSpeedOut, ?quickAccel, ?quickDecel);

			% Conditions to set and reset isEnabled
			if (not isEnabled and ?cruiseState = 2 or ?cruiseState = 3 or ?cruiseState = 4) then
				isEnabled := true;
				onPressedOut := false;
			elsif (?cruiseState = 1) then
				isEnabled := false;

			% Initially set cruise speed when on pressed (This should only update once)
			elsif (?on and not(onPressedOut) and speedInRange and isEnabled) then
				cruiseSpeedOut := ?speed;
				onPressedOut := true;

			% If set is pressed thereafter, set the new speed
			elsif (?set and onPressedOut and speedInRange) then
				cruiseSpeedOut := ?speed;

			% Check if incrementing speed will still be within range 
			% Also make sure both quickAccel and quickDecel arent true at the same time
			elsif (?quickAccel and not(?quickDecel) and isEnabled and checkSpeedInc) then
				cruiseSpeedOut := cruiseSpeedOut + speedInc;
			
			% Check if decrementing speed will still be within range
			elsif (?quickDecel and not(?quickAccel) and isEnabled and checkSpeedInc) then
				cruiseSpeedOut := cruiseSpeedOut - speedInc;
			end if;

			emit cruiseSpeed(cruiseSpeedOut);
	end loop
	end var
	end var

end module


% Cruise state management module, handles state transitions (Krishen)
module StateController:
	input on: boolean, off : boolean, resume : boolean;
	input speed := 0.0f : float;
	input accel : float, brake : float;

	% Cruise State:
	% 	1 = OFF
	% 	2 = ON
	% 	3 = STDBY
	% 	4 = DISABLE
	output cruiseState : integer;

	function checkAccelPedal(float) : boolean;
	function checkBrakePedal(float) : boolean;
	function checkSpeedInRange(float) : boolean;

	% Brake Pressed and AccelPressed cannot be high at the same time
	% relation brakePressed # accelPressed;

	var currentState := 1 : integer in
	var speedInRange : boolean, accelPressed : boolean, brakePressed : boolean in
	loop
		pause;
		speedInRange := checkSpeedInRange(?speed);
		accelPressed := checkAccelPedal(?accel);
		brakePressed := checkBrakePedal(?brake);
		
		% Move to OFF when off pressed (priority)
		if (?off) then 
			currentState := 1;

		%  Output ON when on button pressed, accelerator not pressed, and speed in range
		elsif (?on or (currentState = 2 and not(accelPressed) and speedInRange)) then
			currentState := 2;

		% Move from ON to DISABLE when accelPressed = false and speed isnt in bounds
		elsif (currentState = 2 and (accelPressed or not(speedInRange))) then
			currentState := 4;
		end if;

		% Move from STDBY to ON when resume pressed, acelerator not pressed, and speed in range
		if (currentState = 3 and ?resume and not(accelPressed) and speedInRange) then
			currentState := 2;
			% The last set cruiseSpeed should be reused here or in speed management?

		% Move from STDBY to DISABLE when resume and (accelerator pressed or speed not in range)
		elsif (currentState = 3 and ?resume and (accelPressed or not(speedInRange))) then
			currentState := 4;
		end if;
			
		% Move to STDBY if the brake is pressed (priority)
		if (brakePressed) then
			currentState := 3;
		end if;

		% Move from DISABLE to ON if accelerator not pressed and speed in range
		if (currentState = 4 and not(accelPressed) and speedInRange) then
			currentState := 2;
			% The last set cruiseSpeed should be reused here or in speed management?
		end if;

		emit cruiseState(currentState);
		
	end loop
	end var
	end var
end module

% Car Driving Control (Krishen)



% Toplevel module running
module cruiseController:

	% Visible inputs/outputs StateController
	input on1 := false : boolean, off1 := false : boolean, resume1 := false : boolean, set1 := false : boolean;
	input quickAccel1 := false : boolean, quickDecel1 := false : boolean;
	input accel1 := 0.0f : float, brake1 := 0.0f : float, speed1 := 0.0f : float;
	
	output cruiseSpeed1 := 0.0f : float;
	output throttleCmd1 := 0.0f : float;
	output cruiseState1 := 1 : integer;

	% I dont think we need this module at all... mainly because it doesnt do anything to make
	% stuff easier for us and also it introduces multiple emits at the same time(which you cant do)
	% The multiple emits happen because the accelPressesd and brakePressed are defined as inputs/outputs
	% because our other functions use them. Decided to incorporate directly into the module (less code)

	% run PedalDetection 
	% [
	% 	signal brake1/brake;
	% 	signal accel1/accel;
	% 	signal accelPressed1/accelPressed;
	% 	signal brakePressed1/brakePressed
	% ]
	
	% ||

	run StateController 
	[
		signal accel1/accel;
		signal brake1/brake;
		signal cruiseState1/cruiseState;
		signal on1/on;
		signal off1/off;
		signal resume1/resume;
		signal speed1/speed
	]

	||

	run SpeedManagement
	[
		signal speed1/speed;
		signal on1/on;
		signal set1/set;
		signal quickAccel1/quickAccel;
		signal quickDecel1/quickDecel;
		signal cruiseSpeed1/cruiseSpeed;
		signal cruiseState1/cruiseState
	]

end module

