% Cruise Speed Management

module SpeedManagement:
	input speed : float;
	input on : boolean, set : boolean, quickAccel : boolean, quickDecel : boolean;
	output cruiseSpeed : float; 
	output cruiseState : integer;

	function checkSpeedInRange(float) : boolean;
	function checkSpeedIncrement(float, boolean, boolean) : boolean;
	
	var onPressedOut := false : boolean, isEnabled := false : boolean, speedInRange : boolean, checkSpeedInc : boolean in
	var speedInc := 2.5f : float, speedOut := 0.0f : float, cruiseSpeedOut := 0.0f : float in
	loop
		pause;
			speedOut := ?speed;
			if (?speed > 150.0f) then
				speedOut := 150.0f;
			elsif (?speed < 30.0f) then
				speedOut := 30.0f;
			end if;
			
			speedInRange := checkSpeedInRange(speedOut);
			checkSpeedInc := checkSpeedIncrement(cruiseSpeedOut, ?quickAccel, ?quickDecel);

			% Conditions to set and reset isEnabled
			if (not isEnabled and (?cruiseState = 2 or ?cruiseState = 3 or ?cruiseState = 4)) then
				isEnabled := true;
				onPressedOut := false;
			elsif (?cruiseState = 1) then
				isEnabled := false;

			% Initially set cruise speed when on pressed (This should only update once)
			elsif (?on and not(onPressedOut) and speedInRange and isEnabled) then
				cruiseSpeedOut := speedOut;
				onPressedOut := true;

			% If set is pressed thereafter, set the new speed
			elsif (?set and onPressedOut and speedInRange) then
				cruiseSpeedOut := speedOut;

			% Check if incrementing speed will still be within range 
			% Also make sure both quickAccel and quickDecel arent true at the same time
			elsif (?quickAccel and not(?quickDecel) and isEnabled and checkSpeedInc) then
				cruiseSpeedOut := cruiseSpeedOut + speedInc;
			
			% Check if decrementing speed will still be within range
			elsif (?quickDecel and not(?quickAccel) and isEnabled and checkSpeedInc) then
				cruiseSpeedOut := cruiseSpeedOut - speedInc;
			end if;

			emit cruiseSpeed(cruiseSpeedOut);
	end loop
	end var
	end var

end module


% Cruise state management module, handles state transitions
module StateController:
	input on: boolean, off : boolean, resume : boolean;
	input speed := 0.0f : float, accel : float, brake : float;

	% Cruise State:
	% 	1 = OFF
	% 	2 = ON
	% 	3 = STDBY
	% 	4 = DISABLE
	output cruiseState : integer;

	function checkAccelPedal(float) : boolean;
	function checkBrakePedal(float) : boolean;
	function checkSpeedInRange(float) : boolean;

	% Brake Pressed and AccelPressed cannot be high at the same time
	% relation brakePressed # accelPressed;

	var currentState := 1 : integer in
	var speedInRange : boolean, accelPressed : boolean, brakePressed : boolean in
	loop
		pause;
		speedInRange := checkSpeedInRange(?speed);
		accelPressed := checkAccelPedal(?accel);
		brakePressed := checkBrakePedal(?brake);
		
		% Move to OFF when off pressed (priority)
		if (?off) then 
			currentState := 1;

		%  Output ON when on button pressed, accelerator not pressed, and speed in range
		elsif (?on or (currentState = 2 and not(accelPressed) and speedInRange)) then
			currentState := 2;

		% Move from ON to DISABLE when accelPressed = false and speed isnt in bounds
		elsif (currentState = 2 and (accelPressed or not(speedInRange))) then
			currentState := 4;
		end if;

		% Move from STDBY to ON when resume pressed, acelerator not pressed, and speed in range
		if (currentState = 3 and ?resume and not(accelPressed) and speedInRange) then
			currentState := 2;

		% Move from STDBY to DISABLE when resume and (accelerator pressed or speed not in range)
		elsif (currentState = 3 and ?resume and (accelPressed or not(speedInRange))) then
			currentState := 4;
		end if;
			
		% Move to STDBY if the brake is pressed (priority)
		if ((currentState = 2 or currentState = 3 or currentState = 4) and brakePressed) then
			currentState := 3;
		end if;

		% Move from DISABLE to ON if accelerator not pressed and speed in range
		if (currentState = 4 and not(accelPressed) and speedInRange) then
			currentState := 2;
		end if;

		emit cruiseState(currentState);
	end loop
	end var
	end var
end module

% Car Driving Control
module DrivingControl:
	input cruiseState : integer, accel : float;
	input speed : float, cruiseSpeed : float;
	output throttleCmd : float;

	% Regulate and saturate throttle given conditions
	function regulateThrottle(integer, float, float) : float;
	
	var throttleCmdOut := 0.0f : float, currentState := 0 : integer, isGoingOn := 0 : integer, enteredOn := false : boolean in 
	loop
		pause;
			currentState := ?cruiseState;
			% Reset isGoingOn when moving to another state
			if (currentState = 1 or currentState = 3 or currentState = 4) then
				isGoingOn := 0;
				enteredOn := false;
			end if;
			
			% Accelerator state, throttleCmd driven by accelerator when cruise OFF
			if (currentState = 1) then
				throttleCmdOut:= ?accel;
			
			% Regulation state, throttleCmd driven by regulate functions when cruise ON
			% Set isGoingOn only when it has JUST moved from another state to ON, otherwise false
			elsif (not enteredOn and currentState = 2) then
				isGoingOn := 1;
				enteredOn := true;
				throttleCmdOut := regulateThrottle(isGoingOn, ?cruiseSpeed, ?speed);
			
			% If we stay in the ON state, don't reset integral part (i.e isGoingOn = 0 (false))
			elsif (enteredOn and currentState = 2) then
				isGoingOn := 0;
				throttleCmdOut := regulateThrottle(isGoingOn, ?cruiseSpeed, ?speed);
				
			end if;
			
			emit throttleCmd(throttleCmdOut);
	end loop
	end var
end module


% Toplevel module running
module CruiseController:

	% Visible inputs/outputs StateController
	input on1 := false : boolean, off1 := false : boolean, resume1 := false : boolean, set1 := false : boolean;
	input quickAccel1 := false : boolean, quickDecel1 := false : boolean;
	input accel1 := 0.0f : float, brake1 := 0.0f : float, speed1 := 0.0f : float;
	
	output cruiseSpeed1 := 0.0f : float;
	output throttleCmd1 := 0.0f : float;
	output cruiseState1 := 1 : integer;

	run StateController 
	[
		signal accel1/accel;
		signal brake1/brake;
		signal cruiseState1/cruiseState;
		signal on1/on;
		signal off1/off;
		signal resume1/resume;
		signal speed1/speed
	]

	||

	run SpeedManagement
	[
		signal speed1/speed;
		signal on1/on;
		signal set1/set;
		signal quickAccel1/quickAccel;
		signal quickDecel1/quickDecel;
		signal cruiseSpeed1/cruiseSpeed;
		signal cruiseState1/cruiseState
	]

	||

	run DrivingControl
	[
		signal cruiseSpeed1/cruiseSpeed;
		signal speed1/speed;
		signal throttleCmd1/throttleCmd;
		signal accel1/accel;
		signal cruiseState1/cruiseState
	]

end module

